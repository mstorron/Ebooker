-- Critical

App-wide silenceability, configuration, logging.

* User abstraction.
* TESTS
** Integration test for the actual command-line client: test flags, etc.
* REFACTORING

* Multiple sources if desired (SrLaurelita)

* Improve the actual text generated.
** Ensure correctness -- some ending conditions are very suspicious.
** Length of generated tweets: ensure no direct subsets?

** "Sweeps," a set of filters that you can apply to the text, 
*** Capitalization.
**** ALLCAPS
**** all lowercase, better known as the "instagram user"
**** Washington Post Style, Where Every Word is Capitalized
**** Force a proper sentence structure.

*** Hashtags
**** coffee dadder#
**** Random #Hashtagging of a word.
**** Chuck Grassleying #CombineWordsIntoOneTag (note that you'd probably want to 
     remove a word from whatever you contract together to make it as 
     weird-as-hell as possible).

-- Later
* Webapp

Features
--------
* Handle asyncronous fetches from Twitter, generation, e.g.
** Actually run as a damn service.


---
A service that

* responds to pings (check if alive)
* Composes, then sends tweets on a schedule, maybe randomized.
* Add to corpus. Probably via a fetch->compare to DB, on a schedule.
* Change/set credentials -> posting as @laurelita_ebooks, for example

API
---

ping -> Responds "pong"
update -> Fetches tweets of the seed
stdout -> creates tweet, prints to stdout
schedule -> alter the tweet schedule.


Plan
----
* Multi-store: have a "canonical" version of a string, with frequency-determined 
  values for the representation of those strings. e.g. just like we have "it's
  a shame", we'd like "It's a shame" to map to the same things, so we have the
  canonical "its" that maps to the representations "It's" and "it's", 50% chance
  of each.

* Add "decorators" things like:
  * Canonicalization of capitalization in input (we want "today is" and "Today 
    is" to map to the same entry).
  * Diversity in end conditions: sometimes it ends abruptly when it reaches the
    end of a chain, other times it'll just freshly pick a new input.
  * Randomization for odd capitalization on output. We'd like tweets to have 
    a silly random quality, like "Today a better Day is For #him."
  * Hashtagger -- maybe run a mostly-completed tweet through a Thesaurus 
    service, return entries to generate #PantsBurnLegWound type silly tags.

  Don't need all of them, maybe just the first since that's less a decoration
  and more of an "as designed."

  - string_utils

* Twitter API stuff: try to fetch tweets, post them. Write the infrastructure
  needed.

  - Fetch tweets more reliably.
  - Store to DB. SQLite? GAE store?

* Write the binary to be a service: persistent Generators of text, scheduled
  fetching of tweets comparing against a database of already fetched tweets.
  Should all be deterministic: the same corpus should yield the same Generator
  (though naturally, the text generated would be non-deterministic...)

  - net/http
  - GAE

* "Launch"! Bugfixes, better features (more of the decorators, non-Twitter 
  sources such as RSS), better "service" definition (e.g. replication, 
  monitoring). Host/generalize on GAE?

Done
----
* Write the Markov text generator first, ensure that it can generate arbitrary
  text for a single prefix length, under a character limit.


